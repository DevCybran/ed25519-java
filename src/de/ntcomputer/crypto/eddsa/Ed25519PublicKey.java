package de.ntcomputer.crypto.eddsa;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;

import de.ntcomputer.crypto.hash.HashCondenser;
import de.ntcomputer.crypto.hash.ProgressListener;
import net.i2p.crypto.eddsa.EdDSAEngine;
import net.i2p.crypto.eddsa.EdDSAPublicKey;
import net.i2p.crypto.eddsa.Utils;
import net.i2p.crypto.eddsa.spec.EdDSAPublicKeySpec;

/**
 * A wrapper class which makes it easy to use Ed25519 public keys.
 * All verify methods are using the {@link HashCondenser} for efficiency.
 * Obtain an instance by loading a key file or using {@link Ed25519PrivateKey#derivePublicKey()}
 * 
 * @author DevCybran
 *
 */
public class Ed25519PublicKey {
	private final EdDSAPublicKey key;
	
	/**
	 * Loads a private key from the specified file.
	 * 
	 * @see #loadFromString(String)
	 * @param publicKeyFile the file to read the private key from
	 * @return the read private key
	 * @throws IOException if an IO error occurs while reading the file
	 * @throws NoSuchAlgorithmException if SHA-512 is not present on this machine
	 * @throws InvalidKeyException if the key file has an invalid format
	 */
	public static Ed25519PublicKey loadFromFile(File publicKeyFile) throws IOException, NoSuchAlgorithmException, InvalidKeyException {
		String key = new String(Files.readAllBytes(publicKeyFile.toPath()), StandardCharsets.UTF_8);
		return loadFromString(key);
	}
	
	/**
	 * Decodes a public key from the specified string.
	 * 
	 * @param publicKeyString A hexadecimal encoded representation of the key, generated by {@link #saveAsString()}
	 * @return the decoded public key
	 * @throws InvalidKeyException if the passed publicKeyString has an invalid format
	 * @throws NoSuchAlgorithmException if SHA-512 is not present on this machine
	 */
	public static Ed25519PublicKey loadFromString(String publicKeyString) throws InvalidKeyException, NoSuchAlgorithmException {
		if(publicKeyString.length() != (256+512)/8*2) throw new InvalidKeyException("the supplied key is not a valid public key"); // key + hash
		byte[] publicKey, publicKeyHashStored, publicKeyHash;
		try {
			publicKey = Utils.hexToBytes(publicKeyString.substring(0,256/8*2));
			publicKeyHashStored = Utils.hexToBytes(publicKeyString.substring(256/8*2));
		} catch(Exception e) {
			throw new InvalidKeyException("the supplied key is not a valid public key", e);
		}
		publicKeyHash = Ed25519PrivateKey.hash(publicKey);
		if(Utils.equal(publicKeyHash, publicKeyHashStored) != 1) throw new InvalidKeyException("the supplied public key is corrupted");
		return new Ed25519PublicKey(new EdDSAPublicKey(new EdDSAPublicKeySpec(publicKey, Ed25519PrivateKey.P_SPEC)));
	}
	
	Ed25519PublicKey(EdDSAPublicKey key) {
		this.key = key;
	}
	
	/**
	 * Encodes and saves this key to the specified file.
	 * 
	 * @see #saveAsString()
	 * @param publicKeyFile the file to save the public key to
	 * @throws IOException if an IO error occurs when writing the file
	 * @throws NoSuchAlgorithmException if SHA-512 is not present on this machine
	 */
	public void saveAsFile(File publicKeyFile) throws IOException, NoSuchAlgorithmException {
		String key = this.saveAsString();
		Files.write(publicKeyFile.toPath(), key.getBytes(StandardCharsets.UTF_8));
	}
	
	/**
	 * Encodes this key as a hexadecimal String.
	 * 
	 * @return a hexadecimal encoded representation of this public key
	 * @throws NoSuchAlgorithmException if SHA-512 is not present on this machine
	 */
	public String saveAsString() throws NoSuchAlgorithmException {
		byte[] publicKey = this.key.getAbyte();
		if(publicKey.length!=256/8) throw new RuntimeException(new InvalidKeyException("unexpected public key length"));
		byte[] publicKeyHash = Ed25519PrivateKey.hash(publicKey);
		return Utils.bytesToHex(publicKey) + Utils.bytesToHex(publicKeyHash);
	}
	
	private boolean verifyLow(byte[] data, String signature) throws SignatureException {
		byte[] signatureBytes;
		try {
			signatureBytes = Utils.hexToBytes(signature);
		} catch(Exception e) {
			throw new SignatureException("the supplied signature has an invalid format", e);
		}
		EdDSAEngine engine = new EdDSAEngine();
		try {
			engine.initVerify(this.key);
			engine.update(data);
			return engine.verify(signatureBytes);
		} catch (InvalidKeyException e) {
			throw new RuntimeException(e);
		}
	}
	
	/**
	 * Verifies the signature of the given byte array.
	 * {@link HashCondenser#compute(byte[])} with default settings is preprocessing the array before verifying its signature.
	 * 
	 * @param data
	 * @param signature a hexadecimal representation of the signature (generated by {@link Ed25519PrivateKey#sign(byte[])}
	 * @return true if the signature is correct. False otherwise.
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws SignatureException if the given signature has an invalid format
	 */
	public boolean verify(byte[] data, String signature) throws NoSuchAlgorithmException, SignatureException {
		return this.verifyLow(HashCondenser.getInstance().compute(data, null), signature);
	}
	
	/**
	 * Verifies the signature of the given String by converting it to bytes using the UTF-8 charset.
	 * 
	 * @see #verify(byte[], String)
	 * @param data
	 * @param signature a hexadecimal representation of the signature (generated by {@link Ed25519PrivateKey#sign(String)}
	 * @return true if the signature is correct. False otherwise.
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws SignatureException if the given signature has an invalid format
	 */
	public boolean verify(String data, String signature) throws NoSuchAlgorithmException, SignatureException {
		return this.verify(data.getBytes(StandardCharsets.UTF_8), signature);
	}
	
	/**
	 * Verifies that the signature for all data which can be read from the given InputStream is correct.
	 * {@link HashCondenser#compute(byte[])} with default settings is preprocessing the stream before verifying its signature, which will allow processing huge files.
	 * 
	 * @param source the data source
	 * @param sourceSize the exact size of all data which will pass through the InputStream
	 * @param signature a hexadecimal representation of the signature (generated by {@link Ed25519PrivateKey#sign(InputStream, long)}
	 * @param listener a progress listener. Optional, may be null.
	 * @return true if the signature is correct. False otherwise.
	 * @throws IllegalArgumentException if sourceSize is not the correct size
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws IOException if an IO error occurs while reading the stream
	 * @throws SignatureException if the given signature has an invalid format
	 */
	public boolean verify(InputStream source, long sourceSize, String signature, ProgressListener listener) throws IllegalArgumentException, NoSuchAlgorithmException, IOException, SignatureException {
		return this.verifyLow(HashCondenser.getInstance().compute(source, sourceSize, listener), signature);
	}
	
	/**
	 * Verifies the signature of the content of the given file.
	 * 
	 * @see #verify(InputStream, long, String)
	 * @param source
	 * @param signature a hexadecimal representation of the signature (generated by {@link Ed25519PrivateKey#sign(File)}
	 * @param listener a progress listener. Optional, may be null.
	 * @return true if the signature is correct. False otherwise.
	 * @throws IOException if an IO error occurs while reading the file
	 * @throws IllegalArgumentException if the file's size changes during computation
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws SignatureException if the given signature has an invalid format
	 */
	public boolean verify(File source, String signature, ProgressListener listener) throws IOException, IllegalArgumentException, NoSuchAlgorithmException, SignatureException {
		if(!source.isFile()) throw new FileNotFoundException(source.getAbsolutePath());
		long fileSize = source.length();
		try(InputStream is = new FileInputStream(source)) {
			return this.verify(is, fileSize, signature, listener);
		}
	}
	
	/**
	 * Verifies the content of the given file against its signature, stored in a file of the same name which has a ".sig" extension appended
	 * Example: If you verify "MyFile.dat", the signature will be read from "MyFile.dat.sig"
	 * 
	 * @see #verifyFromFile(File, File)
	 * @param source
	 * @param listener a progress listener. Optional, may be null.
	 * @return true if the signature is correct. False otherwise.
	 * @throws IOException if an IO error occurs while reading a file
	 * @throws IllegalArgumentException if the file's size changes during computation
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws SignatureException if the signature in the .sig file has an invalid format
	 */
	public boolean verifyFromFile(File source, ProgressListener listener) throws IOException, IllegalArgumentException, NoSuchAlgorithmException, SignatureException {
		return this.verifyFromFile(source, new File(source, ".sig"), listener);
	}
	
	/**
	 * Verifies the content of the given source file against the signature in the given signature file.
	 * 
	 * @see #verify(File, String)
	 * @param source
	 * @param signatureFile the file to write the signature to
	 * @param listener a progress listener. Optional, may be null.
	 * @return true if the signature is correct. False otherwise.
	 * @throws IOException if an IO error occurs while reading a file
	 * @throws IllegalArgumentException if the file's size changes during computation
	 * @throws NoSuchAlgorithmException if the hash algorithm is not present on this machine
	 * @throws SignatureException if the signature in the signature file has an invalid format
	 */
	public boolean verifyFromFile(File source, File signatureFile, ProgressListener listener) throws IOException, IllegalArgumentException, NoSuchAlgorithmException, SignatureException {
		String signature = new String(Files.readAllBytes(signatureFile.toPath()), StandardCharsets.UTF_8);
		return this.verify(source, signature, listener);
	}

}
